### 经典游戏服务器端架构(分服模型)

---

对于游戏服务端架构，最重要的三个部分：

1. 内存架构

   主要决定服务器如何使用内存，以保证尽量少的内存泄漏的可能，以及最大化利用服务器端内存来提高承载量，降低服务延迟。

2. 调度架构

   设计如何使用进程、线程、协程这些对于CPU调度的方案。选择同步、异步等不同的编程模型，以提高服务器的稳定性和承载量。同时也要考虑对于开发带来的复杂度问题。现在出现的虚拟化技术，如虚拟机、docker、云服务器等，都为调度架构提供了更多的选择。

3. 通信模式

   决定使用何种方式通讯。网络通讯包含有传输层的选择，如TCP/UDP；据表达层的选择，如定义协议；以及应用层的接口设计，如消息队列、事件分发、远程调用等。

服务器模型的进化过程：

- 早期的游戏服务器

  基本上只是一个广播和存储文件的服务器程序

- MUD模型

  主要运行逻辑在服务器端的架构

- 全区型架构

---

#### 分服模型

##### 模型描述

分服模型是游戏服务器中最典型，也是历久最悠久的模型。其特征是游戏服务器是一个个单独的世界。

每个服务器上的账号是独立的，只有同一个服务器上的账号才能产生交互(现在很多游戏也是这样的)

在早期服务器的承载量达到上限的时候，游戏开发者就通过架设更多的服务器来解决。这样提供了很多个游戏的“平行世界”，让游戏中的人人之间的比较，产生了更多的空间。

![12 经典游戏服务器端架构概述](https://www.javazhiyin.com/wp-content/uploads/2018/08/java_10-1534141189.jpg)

##### 调度框架

1. **单进程游戏服务器**

   单进程服务器即游戏服务器只有一个进程，为了处理来自客户端的并发数据，有很多的选择方法：

   - 同步-动态多线程

     <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfrn9lc3tj30gk0fggox.jpg" alt="截屏2020-11-06 下午9.19.11" style="zoom:50%;" />

     没接收一个用户会话，就建立一个线程，用户会话往往是由客户端的TCP连接来代表，这样每次从socket中调用读取或写出数据包的时候，都可以使用阻塞模式。

     **特点：** 

     - 编码简单，有多少客户端的连接就有多少线程

     **缺点：**

     - 容易产生大量线程
     - 线程间的切换需要造成cpu性能损失
     - 对内存占用不好控制，需要加锁，可能会出现死锁bug

     **综上所述，这个方案比较适合有较少客户端连接的服务器，但是当规模比较大的时候就不OK了**

   - 同步-多线程池

     <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfru7c0waj30hm0gcgpf.jpg" alt="截屏2020-11-06 下午9.25.54" style="zoom:50%;" />

     该模型加入了线程池，每次用户会话建立的时候，向线程池申请处理线程的使用，在用户断开连接的时候，线程不退出，而是向线程池"释放"对此线程的使用

     特点：

     - 引入线程池之后可以很好地控制线程的数量，不会造成暴增的现象

     缺点：

     - 线程池的实现本身比较复杂
     - "申请"、"释放"线程的调用规则需要严格遵循，否则会发生线程资源会很快耗尽的现象

     一个问题：当客户端数量比较多的时候，造成排队现象，这种情况该如何处理呢？

   - 异步-单线程/协程

     <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfs4py8kgj30j20igq6k.jpg" alt="截屏2020-11-06 下午9.35.55" style="zoom:50%;" />

     服务器中的调用比如说(网络调用)是异步操作的，这样可以使得仅使用一个单线程即可实现高并发通信，同样解决了多线程之间的并发问题(因为只有一个线程)

     特点：

     - 单线程即可实现高并发
     - 解决了多线程的锁的问题

     缺点：

     - 不能充分利用cpu资源，因为单线程只能使用一个CPU
     - 异步编程是基于"回调"函数的，因此会定义很多的回调函数，对于代码的阅读不OK

     但针对上述问题，协程的出现可以提供较好的帮助，因此现在比较流行的架构是**单线程+协程**的组合

   - 异步-固定多线程

     ![截屏2020-11-06 下午9.49.23](https://tva1.sinaimg.cn/large/0081Kckwgy1gkfsinpb13j30ly0i8jx8.jpg)

     这是基于异步-单线程模型进化出来的一种模型。这种模型一般有三类线程：主线程、IO线程、逻辑线程。这些线程都在内部以全异步的方式运行，而他们之间通过无锁消息队列通信。

2. **多进程游戏服务器**

   多进程的游戏服务器系统，最早起源于对于性能问题需求。由于单进程架构下，总会存在承载量的极限，越是复杂的游戏，其单进程承载量就越低，因此开发者们一定要突破进程的限制，才能支撑更复杂的游戏。

   多进程的好处：

   - 可以充分利用多核CPU的能力
   - 利用操作系统的工具能更仔细的监控到运行状态、更容易进行容灾处理

   在多进程中比较经典的架构是"**三层架构**"

   在多进程架构下，开发者一般倾向于把每个模块的功能，都单独开发成一个进程，然后以使用进程间通信来协调处理完整的逻辑。

   ![截屏2020-11-06 下午9.57.07](https://tva1.sinaimg.cn/large/0081Kckwgy1gkfsqs6qraj317m0lwgx7.jpg)

   在三层模型中，使用的思想是典型的"**管道与过滤器**"架构思想

   > *管道与过滤器架构*：把每个进程看成是一个过滤器，用户发来的数据包，流经多个过滤器衔接而成的管道，最后被完整的处理完

   由于使用了多进程，所以首选使用单进程单线程来构造其中的每个进程。这样对于程序开发来说，结构清晰简单很多，也能获得更高的性能。

   三层模型的缺点：

   - 数据存储

     由于要保证数据的一致性，所以存储进程一般都难以切分成多个进程，就算对关系型数据做分库分表处理，也是非常复杂的，对业务类型有依赖的。而且如果单个逻辑处理进程承载不了，由于其内存中的数据难以分割和同步，开发者很难去平行的扩展某个特定业务逻辑。

     开发者可能会选择把存储设置成**无状态**的，但是这又加重了存储进程的压力，因为每次业务处理都需要去存储进程拉取或写入数据

   - 运维和开发的问题

     - 首先就是整个系统的部署更为复杂了，因为需要对多个不同类型进程进行连接配置，造成大量的配置文件需要管理
     - 进程间的通信也比较多，因此需要定义的协议数量也十分庞大，造成整个源代码数量庞大
     - 整个系统被分割成功能较小的代码段之后，如果不了解整体架构的话，很难理解一个完成的业务流程如何被处理，让代码的交接成本极大

##### 内存架构

由于服务器需要长时间运行，因此一个优秀的内存架构是非常重要的

1. 动态内存

   简单来讲就是在需要的时候来申请内存，在不同的编程语言中，内存的分配和释放策略也不同

2. 预分配内存

   由于游戏业务往往用到的数据结构非常多，变化很大，因此内存管理的风险很高，动态内存的风险就相对较高了，因此许多的团队采用了预分配内存的结构。在服务器启动的时候分配所有的变量，不需要再使用new了

   这样做的好处：

   - 有效减少内存漏洞的出现概率
   - 降低动态分配内存所消耗的性能
   - 同时由于启动时分配内存，如果硬件资源不够的话，进程就会在启动时失败，而不是像动态分配内存的程序一样，可能在任何一个分配内存的时候崩溃

   如果要实现预分配内存，需要在编码上遵循"动态分配架构"中对象树的原则：

   > 把一类对象构造为“根”对象，然后用一个内存池来管理这些根对象。而这个内存池能存放的根对象的数目，就是此服务进程的最大承载能力

   由于一切都是在启动时决定，因此比较稳妥可靠

   ![截屏2020-11-07 下午8.02.51](https://tva1.sinaimg.cn/large/0081Kckwgy1gkgv25xa4dj31de0is49y.jpg)

   缺点：

   - 不好部署
   - 每次更换环境都需要修改这个配置
   - 是所有的用到的类对象，都要在根节点对象那里有个指针或者引用，否则就可能泄漏内存

#### 进程间的通讯手段

1. Socket通讯

   TCP/IP协议是一种通用的、跨语言、跨操作系统、跨机器的通讯方案。在使用上，有两种选择：TCP和UDP，一般更倾向于选择TCP，因为游戏数据的逻辑相关性比较强，UDP由于可能存在的丢包和重发处理，在游戏逻辑上的处理一般比较复杂。同时，**由于多进程系统的进程间的网络一般比较好，UDP的性能优势不会特别明显**

   使用TCP的优点：

   - 通用性广，你可以用来实现任何的功能，和任何的进程进行协作

   使用TCP的缺点：

   - 开发量比较大，虽然现在有一些开源组件，可以帮你简化Socket Server的编写工作，简化连接管理和消息分发的处理，但是选择目标建立连接、定制协议编解码这两个工作往往还是要自己去做。
   - 游戏的特点是业务逻辑变化很多，导致协议修改的工作量非常大。

   ![截屏2020-11-07 下午8.49.54](https://tva1.sinaimg.cn/large/0081Kckwgy1gkgwf2st48j31dc0cs0vq.jpg)

2. 消息队列

   在多进程系统中，如果进程的种类比较多，而且变化比较快，大量编写和配置进程之间的连接是一件非常繁琐的工作，所以开发者就发明了一种简易的通讯方法——消息队列。这种方法的底层还是Socket通讯实现，但是使用者只需要好像投递信件一样，把消息包投递到某个“信箱”，也就是队列里，目标进程则自动不断去“收取”属于自己的“信件”，然后触发业务处理。

   优点：

   - 简单易懂，使用者只需要处理"投递和"收取"两个操作，对于消息也只需要处理“编码”和“解码”两个部分，在Linux环境下，我们还可以利用共享内存，来承担消息队列的存储器，这样不但性能很高，而且还不怕进程崩溃导致未处理消息丢失。

   缺点：

   - 还是要自己对消息进行编解码，并且分发给所需要的处理程序。
   - 在消息到处理程序之间，存在着一个转换和对应的工作。由于游戏逻辑的繁多，这种对应工作完全靠手工编码，是比较容易出错的。

3. 远程调用(Remote Procedure Call)

   有一些开发者会希望，在编码的时候完全屏蔽是否跨进程在进行调用，完全可以好像调用本地函数或者本地对象的方法一样。于是诞生了很多远程调用的方案，最经典的有Corba方案，它试图实现能在不同语言的代码直接，实现远程调用。JAVA虚拟机自带了RMI方案的支持，在JAVA进程之间远程调用是比较方便的。在互联网的环境下，还有各种Web Service方案，以HTTP协议作为承载，WSDL作为接口描述。

   优点：

   - 最大好处是开发的便捷，你只需要写一个函数，就能在任何一个其他进程上对此函数进行调用。这对游戏开发来说，就解决了多进程方案最大的一个开发效率问题。

   缺点：

   - 一般来说，远程调用的性能会稍微差一点，因为需要用一套统一的编解码方案。
   - 如果你使用的是C/C++这类静态语言，还需要使用一种IDL语言来先描述这种远程函数的接口

   但是这些困难带来的好处，是值得的

   ![截屏2020-11-07 下午9.12.37](https://tva1.sinaimg.cn/large/0081Kckwgy1gkgx2reakzj31dg0e6acr.jpg)

   #### 容灾和扩容手段

   在多进程模型中，由于可以采用多台物理服务器来部署服务进程，所以为容灾和扩容提供了基础条件。
       在单进程模型下，容灾常常使用的热备服务器，依然可以在多进程模型中使用，但是开着一台什么都不做的服务器完全是为了做容灾，多少有点浪费。所以在多进程环境下，我们会启动多个相同功能的服务器进程，在请求的时候，根据某种规则来确定对哪个服务进程发起请求。

   如果这种规则能规避访问那些“失效”了的服务进程，就自动实现了容灾，如果这个规则还包括了“更新新增服务进程”的逻辑，就可以做到很方便的扩容了。而这两个规则，统一起来就是一条：**对服务进程状态的集中保存和更新**。

   为了实现上面的方案，常常会架设一个“目录”服务器进程。这个进程专门负责搜集服务器进程的状态，并且提供查询。ZooKeeper就是实现这种目录服务器的一个优秀工具。

   ![截屏2020-11-07 下午9.15.49](https://tva1.sinaimg.cn/large/0081Kckwgy1gkgx6jylt4j31cw0f242d.jpg)

   使用无状态的进程来做扩容和容灾的原因：

   > 尽管用简单的目录服务器可以实现大部分容灾和扩容的需求，但是如果被访问进程的内存中有数据存在，那么问题就比较复杂了。对于容灾来说，新的进程必须要有办法重建那个“失效”了的进程内存中的数据，才可能完成容灾功能；对于扩容功能来说，新加入的进程，也必须能把需要的数据载入到自己的内存中才行，而这些数据，可能已经存在于其他平行的进程中，如何把这部分数据转移过来，是一个比较耗费性能和需要编写相当多代码的工作。

---

参考资料：

[经典游戏服务器端架构概述](https://www.javazhiyin.com/11436.html)